1. IAction 기반 상태 전환 구조 (ActionBase 기반 상태 변환)

ActionBase를 상속받아 다양한 액션(전투, 인벤토리, 캐릭터 정보, 상점, 퀘스트 등)을 독립적으로 구현하고,
SubActionMap을 통해 하위 행동을 관리하는 구조를 사용했습니다.
각 액션들은 일종의 상태처럼 동작하면서, 유연하게 화면과 로직 전환이 가능하도록 설계했습니다.

특히 액션 간 전환은 IAction 인터페이스를 통해 이루어집니다.
덕분에 각 액션은 다른 액션의 구현 세부사항을 몰라도 상호작용할 수 있어,
OCP(개방-폐쇄 원칙)과 DIP(의존성 역전 원칙)을 자연스럽게 만족합니다.

이러한 구조 덕분에 새로운 액션을 추가하거나 기존 액션을 수정할 때,
다른 코드에 영향 없이 독립적으로 작업할 수 있어 유지보수성과 확장성이 뛰어납니다.

또한 SubActionMap을 통해 사용자의 입력에 따라 하위 액션을 유동적으로 관리하고,
선택지에 따른 상태 전환을 자연스럽게 이어갈 수 있도록 구현했습니다.

결과적으로 복잡한 흐름을 가진 콘솔 RPG 시스템에서도
액션 추가 및 수정이 쉽고, 화면 전환 로직이 깔끔하게 유지될 수 있도록 설계되었습니다.

2. 전투 시스템 세분화
공격, 스킬 사용, 포획 세 가지 행동을 분리해서 관리.

전투 턴제 구현 (AttackAction, EnemyAttackAction, ResultAction 등으로 구분).

전투 결과(승리/패배)에 따라 다음 행동을 자동으로 연결.


3. UI 출력 추상화
UiManager.UIUpdater()를 통해 UI 갱신을 일괄적으로 처리.

전투, 상점, 퀘스트 등 서로 다른 화면에서도 일관된 방식으로 UI를 업데이트.


4. 페이징 시스템 (PagedListActionBase)
몬스터 박스, 인벤토리, 상점 등에서 아이템/몬스터 리스트를 페이지 단위로 나누어 출력.

PagedListActionBase를 상속받아 쉽게 재사용 가능.


5. 데이터 테이블 활용
MonsterTable, ItemTable, SkillTable 등에서 데이터를 가져오는 방식 사용.

타입별 데이터 구성을 통해 유지보수가 용이하게 만듦.


6. 퀘스트 시스템 설계
퀘스트 수락, 완료, 포기 기능을 별도로 분리.

선행 퀘스트, 완료 조건, 보상 수령 등도 관리 가능.

7. 아이템 시스템 설계
장비 아이템과 소모품 아이템을 구분해서 처리.

장착/해제 기능을 명확하게 분리 (EquipAction).

아이템 구매, 판매 기능을 상점 시스템에 통합.


8. 몬스터 포획 및 수집 시스템
전투 중 포획 기능 (CatchAction) 구현.

포획 성공 확률은 남은 HP에 따라 동적으로 계산.

포획된 몬스터는 몬스터 박스에 자동 추가.



사용한 주요 기술 스택
언어: C#

UI 관리: 텍스트 기반 UIManager 시스템

페이징 처리: PagedListActionBase 패턴

OOP 원칙: SOLID 원칙 준수
