# 🎮 콘솔 RPG 시스템 설계 문서

텍스트 기반 콘솔 RPG 시스템의 설계 구조 및 구현 방식을 정리한 문서입니다.  
SOLID 원칙을 기반으로 유지보수성과 확장성을 고려한 구조로 구성되었습니다.

---

## 1. IAction 기반 상태 전환 구조 (ActionBase 기반 상태 변환)

ActionBase를 상속받아 다양한 액션(전투, 인벤토리, 캐릭터 정보, 상점, 퀘스트 등)을 독립적으로 구현하고,  
SubActionMap을 통해 하위 행동을 관리하는 구조를 사용했습니다.  
각 액션들은 일종의 상태처럼 동작하면서, 유연하게 화면과 로직 전환이 가능하도록 설계했습니다.

특히 액션 간 전환은 IAction 인터페이스를 통해 이루어집니다.  
덕분에 각 액션은 다른 액션의 구현 세부사항을 몰라도 상호작용할 수 있어,  
**OCP(개방-폐쇄 원칙)**과 **DIP(의존성 역전 원칙)**을 자연스럽게 만족합니다.

이러한 구조 덕분에 새로운 액션을 추가하거나 기존 액션을 수정할 때,  
다른 코드에 영향 없이 독립적으로 작업할 수 있어 유지보수성과 확장성이 뛰어납니다.

또한 SubActionMap을 통해 사용자의 입력에 따라 하위 액션을 유동적으로 관리하고,  
선택지에 따른 상태 전환을 자연스럽게 이어갈 수 있도록 구현했습니다.

결과적으로 복잡한 흐름을 가진 콘솔 RPG 시스템에서도  
액션 추가 및 수정이 쉽고, 화면 전환 로직이 깔끔하게 유지될 수 있도록 설계되었습니다.

---

## 2. 전투 시스템 세분화

- 공격, 스킬 사용, 포획 세 가지 행동을 분리해서 관리.
- 전투 턴제 구현 (`AttackAction`, `EnemyAttackAction`, `ResultAction` 등으로 구분).
- 전투 결과(승리/패배)에 따라 다음 행동을 자동으로 연결.

---

## 3. UI 출력 추상화

- `UiManager.UIUpdater()`를 통해 UI 갱신을 일괄적으로 처리.
- 전투, 상점, 퀘스트 등 서로 다른 화면에서도 일관된 방식으로 UI를 업데이트.

---

## 4. 페이징 시스템 (PagedListActionBase)

- 몬스터 박스, 인벤토리, 상점 등에서 아이템/몬스터 리스트를 페이지 단위로 나누어 출력.
- `PagedListActionBase`를 상속받아 쉽게 재사용 가능.

---

## 5. 데이터 테이블 활용

- `MonsterTable`, `ItemTable`, `SkillTable` 등에서 데이터를 가져오는 방식 사용.
- 타입별 데이터 구성을 통해 유지보수가 용이하게 만듦.

---

## 6. 퀘스트 시스템 설계

- 퀘스트 수락, 완료, 포기 기능을 별도로 분리.
- 선행 퀘스트, 완료 조건, 보상 수령 등도 관리 가능.
- 동일한 행동(예: 특정 아이템 구매, 특정 몬스터 처치)이 여러 퀘스트 조건에 동시에 해당될 경우, 모든 관련 조건의 진행도를 올릴 수 있도록 설계하여 일관성과 확장성을 확보

---

## 7. 아이템 시스템 설계

- 장비 아이템과 소모품 아이템을 구분해서 처리.
- 장착/해제 기능을 명확하게 분리 (`EquipAction`).
- 아이템 구매, 판매 기능을 상점 시스템에 통합.

---

## 8. 몬스터 포획 및 수집 시스템

- 전투 중 포획 기능 (`CatchAction`) 구현.
- 포획 성공 확률은 남은 HP에 따라 동적으로 계산.
- 포획된 몬스터는 몬스터 박스에 자동 추가.

---

## 사용한 주요 기술 스택

- **언어**: C#
- **UI 관리**: 텍스트 기반 `UIManager` 시스템
- **페이징 처리**: `PagedListActionBase` 패턴
- **OOP 원칙**: SOLID 원칙 준수

---
